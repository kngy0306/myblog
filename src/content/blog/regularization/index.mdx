---
title: "DBの正規化について"
date: 2022-06-04T08:58:58+09:00
tags: ["db"]
description: "「達人に学ぶDB設計徹底指南書」をもとにDBの正規化についてまとめた記事です。"
---

import { Image } from "astro:assets";
import regularization_1 from "./regularization_1.jpg";
import regularization_2_before from "./regularization_2_before.jpg";
import regularization_2 from "./regularization_2.jpg";
import regularization_3_before from "./regularization_3_before.jpg";
import regularization_3 from "./regularization_3.jpg";
import conclusionImage from "./conclusion_image.jpg";

[達人に学ぶDB設計徹底指南書](https://www.amazon.co.jp/%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6DB%E8%A8%AD%E8%A8%88-%E5%BE%B9%E5%BA%95%E6%8C%87%E5%8D%97%E6%9B%B8-%E5%88%9D%E7%B4%9A%E8%80%85%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%9F%E3%81%8F%E3%81%AA%E3%81%84%E3%81%82%E3%81%AA%E3%81%9F%E3%81%B8-%E3%83%9F%E3%83%83%E3%82%AF/dp/4798124702)を読み、第3章〜第5章に書かれている、DBの正規化、そのメリットデメリットについてまとめました。

# なぜ正規化をするのか

何も考えずにDB設計を行うと、以下のような問題が発生するかもしれません。

- 同じデータが複数のテーブルに存在してしまい冗長になってしまう
- データ登録ができなくなってしまう

上記のような冗長性、非一貫性を解決することを正規化と言います。

# 第1正規形

第1正規形を満たす条件は、「1つのセルには1つの値しか含まない」です。

<Image src={regularization_1} alt="regularization_1" class="w-3/4 mx-auto rounded-md shadow-lg" />

第1正規形を行う理由は、主キーが列の値を一意に決められない問題を解決することです。
1つの値を決めると、もう1つの値も決まることを関数従属と言います。
正規化は、関数従属性を満たすように整理していく作業とも言いかえることができます。

# 第2正規形

第2正規形を満たす条件は、「部分関数従属がない」ことです。

第2正規形を満たしていないテーブル

<Image src={regularization_2_before} alt="regularization_1" class="w-3/4 mx-auto rounded-md shadow-lg" />

上のテーブルは`school_id`と`student_number`の2つが主キーです。
このテーブルは、**部分関数従属**が存在しています。部分関数従属というのは、主キーの一部に関数従属があることです。
上のテーブルでいうと、`school_name`は`school_id`だけに関数従属しています。

部分関数従属に対し、`student_name`のように2つの主キーをもとに値が決まる関係を、完全関数従属と言います。

第2正規形を満たしているテーブル

<Image src={regularization_2} alt="第2正規形を満たしているテーブル" class="w-3/4 mx-auto rounded-md shadow-lg" />

上の図は、第2正規形を満たすようにテーブルをstudentテーブルとschoolテーブルへ分割しました。

第2正規形を行うメリットは、冗長性の解消です。これによりデータの登録、更新時の処理が簡単になります。

たとえば、`school_name`が変更になったとき、第2正規形を満たしていないテーブルでは、該当するすべて行を更新する必要がありました。
第2正規化を行ったテーブルであれば、schoolテーブルの1行だけを更新するだけで済みます。

また、`student_number`がまだ決まっていないが`school_id`と`school_name`を追加したくなったという例が発生した場合（生徒はまだいないが新しい学校が設立されたとする）、第2正規形を満たしていないテーブルでは`student_number`を仮の値にしないと登録できませんでしたが、第2正規化を行ったテーブルであれば、schoolテーブルに新たな値を登録するだけで解決します。studentデーブルは、schoolテーブルの変更を気にしません。

# 第3正規形

第3正規形を満たす条件は、「推移的関数従属がない」ことです。

第3正規形を満たしていないテーブル

<Image
  src={regularization_3_before}
  alt="第3正規形を満たしていないテーブル"
  class="w-3/4 mx-auto rounded-md shadow-lg"
/>

上のテーブルには**推移的関数従属**が存在しています。推移的関数従属というのは、主キー以外のカラムに関数従属があることです。
上のテーブルでいうと、`activity_name`は`activity_code`に関数従属しています。
`activity_code`は主キーに関数従属しているため、

`主キー`　→　`activity_code`　→　`activity_name`

という段階的な関数従属が存在しています。

第3正規形を満たしているテーブル

<Image src={regularization_3} alt="第3正規形を満たしているテーブル" class="w-3/4 mx-auto rounded-md shadow-lg" />

上の図は、第3正規形を満たすようにテーブルをstudentテーブルとactivityテーブルへ分割しました。

第3正規化を行う理由は、第2正規化と同様にデータ登録時の不都合解消にあります。

新たな`activity_name`を登録したいとき、第3正規化を行っていないテーブルでは主キーも同時に登録しないといけません。
第3正規化を行ったことで、新たなactivity_nameを登録・更新するときはactivityテーブルの変更を行うだけになります。

# 正規化を行うデメリット

正規化を行うデメリットは、SQLのパフォーマンス低下につながることです。

<Image src={conclusionImage} alt="conclusion_image" class="w-3/4 mx-auto rounded-md shadow-lg" />

例として、`student_name`、`school_name`、`activity_name`を取得したい場合、第1正規形のみを満たしたstudentテーブルでは、studentテーブルのみを参照するだけで取得できます。
それに対し第3正規形まで満たしているテーブルでは、studentテーブル、activityテーブル、schoolテーブルを結合してデータを取得する必要があります。

SQLでのデータ検索において、テーブルの結合はパフォーマンスが悪化します。
そのため正規化とパフォーマンスにはトレードオフの関係があります。
